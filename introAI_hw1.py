# Kevin O'Neill
# keoneill
# HW1

################
# 5) 
import random

def quicksort(lyst):
	quicksortHelper(lyst, 0, len(lyst) - 1)

def quicksortHelper(lyst, left, right):
	if left < right:
		pivotLocation = partition(lyst, left, right)
		quicksortHelper(lyst, left, pivotLocation - 1)
		quicksortHelper(lyst, pivotLocation + 1, right)

def partition(lyst, left, right):
	#find the pivot and exchange it with the last item
	middle = (left + right) // 2
	pivot = lyst[middle]
	lyst[middle] = lyst[right]
	lyst[right] = pivot
	#set boundary point to first position
	boundary = left
	#move items less than pivot to the left
	for index in range(left, right):
			if lyst[index] < pivot:
				swap(lyst, index, boundary)
				boundary += 1
	#exchange the pivot item and the boundary item
	swap(lyst, right, boundary)
	return boundary

def swap(lyst, i , j):
	#exchanges the items at positions i and j.
	temp = lyst[i]
	lyst[i] = lyst[j]
	lyst[j] = temp

#############################################
# function1:  Define a custom function (not the built in list.sort() method) that takes as input an 
#    unsorted list of integers and returns the result of sorting that list in ascending order.
def function1(ls):
	length = len(ls)
	newList = []
	#print ls
	for i in range(length):
		temp = min(ls)
		ls.remove(temp)
		newList.append(temp)
	print newList

###########################
# function2	
def function2(arr, n):
	length = len(arr)
	counter = 0
	for i in range(length):
		if (arr[i] == n):
			counter += 1
	print counter

############################
# function3: Define a function that takes as input a depth and then prints out 
#            Pascal's Triangle to that depth
def function3(depth):
	triangle = []
	for i in range(depth):
		triangle.append(makeNewRow(i))
	for i in range(depth)
	print triangle 

def makeNewRow(length):
	newRow = []
	for i in range(length+1):
		newRow.append(1)
	return newRow
	

	
def generate_pascals_triangle(rows):
    """ Returns a list of rows of a Pascal's Triangle with how many rows you want """
    triangle = [[1], [1, 1]]
    if rows == 1:
        return triangle[0]
    else:
        for row_number in range(2, rows):
            triangle.append([1]*row_number)
            for number in range(1, row_number):
                triangle[row_number][number] = (triangle[row_number-1][number-1]+triangle[row_number-1][number])
            triangle[row_number].append(1)
        return triangle

def difference_between_rows(row, next_row):
    """ Returns the difference between two rows in the formatted way """
    row_len = 0
    next_row_len = 0
    for number in row:
        string_number = str(number)
        row_len += (len(string_number)+1)
    for number in next_row:
        string_number = str(number)
        next_row_len += (len(string_number)+1)
    return (next_row_len-1) - (row_len-1)

def print_pascals_triangle(triangle):
    """ Prints the Pascal's Triangle previously generated by generate_pascals_triangle in a formatted form """
    for row in triangle:
        difference = int((difference_between_rows(row, triangle[len(triangle)-1]))/2)
        for number in range(len(row)):
            row[number] = str(row[number])
        print ((' ')*(difference), ' '.join(row))


def main():
	#5
	#function1([5,1,4,7,3,2])
	#function1([1,5,5,3,2,6,2])
	#ls = [random.randrange(0,100) for _ in range(10000)]
	#function1(ls)
	#quicksort(ls)

	
	#6
	#print ">>> function2([1, 1, 2, 4], 8)"
	#function2([1, 1, 2, 4], 8)
	#print ">>> function2([1, 2, 2, 3, 5, 5, 6], 5)"
	#function2([1, 2, 2, 3, 5, 5, 6], 5)
	
	#7
	function3(5)
	#rows = int(input('Enter the number of rows you want in your Pascal`s Triangle: '))
	#print_pascals_triangle(generate_pascals_triangle(rows))

main()
